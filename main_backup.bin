#include <glad/glad.h>
#include <GLFW/glfw3.h>

// Dear ImGui (assumed to be integrated with GLFW/OpenGL3 backends)
#include "imgui.h"
#include "imgui_impl_glfw.h"
#include "imgui_impl_opengl3.h"

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>

// ----- Window Dimensions -----
const unsigned int WIDTH = 800, HEIGHT = 600;

// ----- Shader Sources -----
const char* vertexShaderSource = R"(
#version 330 core
layout (location = 0) in vec3 aPos;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main(){
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
)";

const char* fragmentShaderSource = R"(
#version 330 core
out vec4 FragColor;
uniform vec4 uColor;
void main(){
    FragColor = uColor;
}
)";

// ----- Geometry ----- //
// Cube geometry for drawing joint markers (36 vertices)
float cubeVertices[] = {
    // Back face
    -0.5f, -0.5f, -0.5f,    0.5f, -0.5f, -0.5f,    0.5f,  0.5f, -0.5f,
     0.5f,  0.5f, -0.5f,   -0.5f,  0.5f, -0.5f,   -0.5f, -0.5f, -0.5f,
    // Front face
    -0.5f, -0.5f,  0.5f,    0.5f, -0.5f,  0.5f,    0.5f,  0.5f,  0.5f,
     0.5f,  0.5f,  0.5f,   -0.5f,  0.5f,  0.5f,   -0.5f, -0.5f,  0.5f,
    // Left face
    -0.5f,  0.5f,  0.5f,   -0.5f,  0.5f, -0.5f,   -0.5f, -0.5f, -0.5f,
   -0.5f, -0.5f, -0.5f,   -0.5f, -0.5f,  0.5f,   -0.5f,  0.5f,  0.5f,
    // Right face
     0.5f,  0.5f,  0.5f,    0.5f,  0.5f, -0.5f,    0.5f, -0.5f, -0.5f,
     0.5f, -0.5f, -0.5f,    0.5f, -0.5f,  0.5f,    0.5f,  0.5f,  0.5f,
    // Bottom face
    -0.5f, -0.5f, -0.5f,    0.5f, -0.5f, -0.5f,    0.5f, -0.5f,  0.5f,
     0.5f, -0.5f,  0.5f,   -0.5f, -0.5f,  0.5f,   -0.5f, -0.5f, -0.5f,
    // Top face
    -0.5f,  0.5f, -0.5f,    0.5f,  0.5f, -0.5f,    0.5f,  0.5f,  0.5f,
     0.5f,  0.5f,  0.5f,   -0.5f,  0.5f,  0.5f,   -0.5f,  0.5f, -0.5f
};

// ----- Joint Data -----
// We now have only two joint types for moveable joints.
// The origin cube is fixed at the world origin and is not part of the IK chain.
enum JointType { YAW, PITCH };

struct Joint {
    glm::vec3 axis;  // Rotation axis (in the joint’s local frame)
    float angle;     // Angle in radians
    JointType type;
};

std::vector<Joint> joints; // The IK chain of moveable joints (origin is fixed)

// Global UI selection for new joint type
JointType uiSelectedJoint = YAW;

// Fixed link length for each added joint
const float linkLength = 1.0f;

// ----- Forward Kinematics (3D) -----
// The first position is always the fixed origin cube.
// For each moveable joint, we apply its rotation and then translate along local X.
std::vector<glm::vec3> computeFK() {
    std::vector<glm::vec3> positions;
    glm::mat4 T = glm::mat4(1.0f);
    // Fixed origin cube at (0,0,0)
    positions.push_back(glm::vec3(T[3]));
    for (size_t i = 0; i < joints.size(); i++) {
        T = T * glm::rotate(glm::mat4(1.0f), joints[i].angle, joints[i].axis)
              * glm::translate(glm::mat4(1.0f), glm::vec3(linkLength, 0, 0));
        positions.push_back(glm::vec3(T[3]));
    }
    return positions;
}

// ----- Maximum Reach Clamping -----
float maxReach() {
    return joints.size() * linkLength;
}

glm::vec3 clampTarget(const glm::vec3 &target) {
    float reach = maxReach();
    if(glm::length(target) > reach)
        return glm::normalize(target) * reach;
    return target;
}

// ----- 3D Damped Least-Squares IK Solver -----
// Only applies if there is at least one moveable joint.
void solveIK3D(const glm::vec3 &rawTarget) {
    if(joints.empty()) return;
    glm::vec3 target = clampTarget(rawTarget);
    int n = joints.size();
    const float lambda = 0.1f;
    const int iterations = 10;
    for (int iter = 0; iter < iterations; iter++) {
        std::vector<glm::vec3> positions;
        std::vector<glm::mat4> Ts;
        glm::mat4 T = glm::mat4(1.0f);
        positions.push_back(glm::vec3(T[3]));  // origin (fixed)
        Ts.push_back(T);
        for (int i = 0; i < n; i++) {
            T = T * glm::rotate(glm::mat4(1.0f), joints[i].angle, joints[i].axis)
                  * glm::translate(glm::mat4(1.0f), glm::vec3(linkLength, 0, 0));
            positions.push_back(glm::vec3(T[3]));
            Ts.push_back(T);
        }
        glm::vec3 p_end = positions.back();
        glm::vec3 error = target - p_end;
        if (glm::length(error) < 0.001f)
            break;
        glm::mat3 A(0.0f);
        std::vector<glm::vec3> J;
        for (int i = 0; i < n; i++) {
            glm::vec3 w = glm::normalize(glm::vec3(Ts[i] * glm::vec4(joints[i].axis, 0.0f)));
            glm::vec3 diff = p_end - positions[i];
            glm::vec3 Ji = glm::cross(w, diff);
            J.push_back(Ji);
            A += glm::outerProduct(Ji, Ji);
        }
        A += lambda * lambda * glm::mat3(1.0f);
        glm::mat3 invA = glm::inverse(A);
        for (int i = 0; i < n; i++) {
            float delta = glm::dot(J[i], invA * error);
            joints[i].angle += delta;
        }
    }
}

// ----- Orbit Camera Controls -----
// World up is (0,0,1); we use spherical coordinates.
float cameraDistance = 8.0f;
float cameraYaw   = glm::radians(45.0f);   // azimuth
float cameraPitch = glm::radians(30.0f);     // elevation

glm::vec3 computeCameraPos() {
    float x = cameraDistance * cos(cameraPitch) * cos(cameraYaw);
    float y = cameraDistance * cos(cameraPitch) * sin(cameraYaw);
    float z = cameraDistance * sin(cameraPitch);
    return glm::vec3(x, y, z);
}

glm::mat4 view;
void updateView(glm::mat4 &viewMatrix) {
    glm::vec3 camPos = computeCameraPos();
    viewMatrix = glm::lookAt(camPos, glm::vec3(0,0,0), glm::vec3(0,0,1));
}

glm::mat4 projection;

// ----- Gizmo for Axis Dragging -----
// Three arrows drawn at the end effector along world X, Y, Z.
struct Arrow {
    glm::vec3 direction;
    glm::vec3 color;
};
std::vector<Arrow> gizmoArrows = {
    { glm::vec3(1,0,0), glm::vec3(1,0,0) },
    { glm::vec3(0,1,0), glm::vec3(0,1,0) },
    { glm::vec3(0,0,1), glm::vec3(0,0,1) }
};
const float arrowLength = 0.5f;

// When dragging, if an arrow is picked, constrainedAxis is set (0,1,2), else -1.
int constrainedAxis = -1;

// ----- Mouse Interaction State -----
bool draggingEndEffector = false;
bool rotatingCamera = false;
double lastMouseX = 0.0, lastMouseY = 0.0;

// Helper: Distance from a point to a line segment in screen space.
float pointToLineDistance(const glm::vec2 &p, const glm::vec2 &a, const glm::vec2 &b) {
    glm::vec2 ab = b - a;
    float t = glm::clamp(glm::dot(p - a, ab) / glm::dot(ab, ab), 0.0f, 1.0f);
    glm::vec2 proj = a + t * ab;
    return glm::length(p - proj);
}

// ----- Mouse Callbacks -----
// Left-click near the end effector (if there’s at least one moveable joint) to drag it.
// Right-click (away from the origin) adds a new joint.
// Middle-click and drag to orbit the camera.
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods) {
    double mouseX, mouseY;
    glfwGetCursorPos(window, &mouseX, &mouseY);
    int w, h;
    glfwGetFramebufferSize(window, &w, &h);
    
    // Get the positions of the chain (first is the fixed origin)
    std::vector<glm::vec3> positions = computeFK();
    glm::vec3 ee = positions.back(); // end effector
    // Project the end effector to screen space.
    glm::vec4 clipPos = projection * view * glm::vec4(ee, 1.0f);
    glm::vec3 ndc = glm::vec3(clipPos) / clipPos.w;
    float screenEE_X = (ndc.x * 0.5f + 0.5f) * w;
    float screenEE_Y = (1.0f - (ndc.y * 0.5f + 0.5f)) * h;
    glm::vec2 eeScreen(screenEE_X, screenEE_Y);
    
    glm::vec2 mousePos(mouseX, mouseY);
    float distToEE = glm::length(mousePos - eeScreen);
    const float pickThreshold = 20.0f;
    
    if (button == GLFW_MOUSE_BUTTON_LEFT) {
        if (action == GLFW_PRESS && positions.size() > 1) {
            int axisConstraint = -1;
            float bestDist = pickThreshold;
            for (int i = 0; i < 3; i++) {
                glm::vec3 arrowTipWorld = ee + arrowLength * gizmoArrows[i].direction;
                glm::vec4 tipClip = projection * view * glm::vec4(arrowTipWorld, 1.0f);
                glm::vec3 tipNDC = glm::vec3(tipClip) / tipClip.w;
                float tipScreenX = (tipNDC.x * 0.5f + 0.5f) * w;
                float tipScreenY = (1.0f - (tipNDC.y * 0.5f + 0.5f)) * h;
                glm::vec2 tipScreen(tipScreenX, tipScreenY);
                float d = glm::length(mousePos - tipScreen);
                if(d < bestDist) {
                    bestDist = d;
                    axisConstraint = i;
                }
            }
            if (axisConstraint != -1 || distToEE < pickThreshold) {
                draggingEndEffector = true;
                constrainedAxis = axisConstraint; // -1 indicates free dragging.
                lastMouseX = mouseX;
                lastMouseY = mouseY;
            }
        } else if (action == GLFW_RELEASE) {
            draggingEndEffector = false;
            constrainedAxis = -1;
        }
    }
    if (button == GLFW_MOUSE_BUTTON_RIGHT && action == GLFW_PRESS) {
        // Right-click away from the fixed origin adds a new moveable joint.
        if (distToEE >= pickThreshold) {
            glm::vec3 newAxis;
            JointType newType = uiSelectedJoint;
            // For a YAW joint, rotate about Z; for a PITCH joint, rotate about Y.
            if(newType == YAW)
                newAxis = glm::vec3(0,0,1);
            else
                newAxis = glm::vec3(0,1,0);
            joints.push_back({ newAxis, 0.0f, newType });
        }
    }
    if (button == GLFW_MOUSE_BUTTON_MIDDLE) {
        if (action == GLFW_PRESS) {
            rotatingCamera = true;
            lastMouseX = mouseX;
            lastMouseY = mouseY;
        } else if (action == GLFW_RELEASE) {
            rotatingCamera = false;
        }
    }
}

void cursor_position_callback(GLFWwindow* window, double xpos, double ypos) {
    if (draggingEndEffector) {
        int w, h;
        glfwGetFramebufferSize(window, &w, &h);
        std::vector<glm::vec3> positions = computeFK();
        glm::vec3 ee = positions.back();
        glm::vec4 clipPos = projection * view * glm::vec4(ee, 1.0f);
        float depth = (clipPos.z/clipPos.w + 1.0f) / 2.0f;
        glm::vec4 viewport(0,0,w,h);
        glm::vec3 winCoord(xpos, h - ypos, depth);
        glm::vec3 target = glm::unProject(winCoord, view, projection, viewport);
        if(constrainedAxis != -1) {
            glm::vec3 dir;
            if(constrainedAxis == 0)      dir = glm::vec3(1,0,0);
            else if(constrainedAxis == 1) dir = glm::vec3(0,1,0);
            else                          dir = glm::vec3(0,0,1);
            glm::vec3 diff = target - ee;
            float projLength = glm::dot(diff, dir);
            target = ee + projLength * dir;
        }
        solveIK3D(target);
    }
    if(rotatingCamera) {
        double dx = xpos - lastMouseX;
        double dy = ypos - lastMouseY;
        lastMouseX = xpos;
        lastMouseY = ypos;
        float sensitivity = 0.005f;
        cameraYaw   += sensitivity * dx;
        cameraPitch += sensitivity * dy;
        cameraPitch = glm::clamp(cameraPitch, glm::radians(-89.0f), glm::radians(89.0f));
        updateView(view);
    }
}

// ----- Shader Compilation Helper -----
GLuint compileShader(GLenum type, const char* source){
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    return shader;
}

int main(){
    // Do not add any moveable joint at startup;
    // the origin cube (index 0) is fixed.
    if(!glfwInit()){
        std::cerr << "Failed to initialize GLFW\n";
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "Robot Arm IK with Fixed Origin & Stand", nullptr, nullptr);
    if(!window){ glfwTerminate(); return -1; }
    glfwMakeContextCurrent(window);
    
    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){
        std::cerr << "Failed to load GLAD\n";
        return -1;
    }
    
    glfwSetMouseButtonCallback(window, mouse_button_callback);
    glfwSetCursorPosCallback(window, cursor_position_callback);
    
    // Setup ImGui.
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGui_ImplGlfw_InitForOpenGL(window,true);
    ImGui_ImplOpenGL3_Init("#version 330");
    ImGui::StyleColorsDark();
    
    GLuint vertShader = compileShader(GL_VERTEX_SHADER, vertexShaderSource);
    GLuint fragShader = compileShader(GL_FRAGMENT_SHADER, fragmentShaderSource);
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertShader);
    glAttachShader(shaderProgram, fragShader);
    glLinkProgram(shaderProgram);
    glDeleteShader(vertShader);
    glDeleteShader(fragShader);
    
    int colorLoc = glGetUniformLocation(shaderProgram, "uColor");
    
    // Setup geometry: cube for joint markers.
    GLuint cubeVAO, cubeVBO;
    glGenVertexArrays(1, &cubeVAO);
    glGenBuffers(1, &cubeVBO);
    glBindVertexArray(cubeVAO);
    glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVertices), cubeVertices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    // Setup geometry: line for drawing the arm.
    GLuint lineVAO, lineVBO;
    glGenVertexArrays(1, &lineVAO);
    glGenBuffers(1, &lineVBO);
    
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1f,0.1f,0.1f,1.0f);
    
    // Setup camera.
    updateView(view);
    projection = glm::perspective(glm::radians(45.0f), (float)WIDTH/HEIGHT, 0.1f, 100.0f);
    
    int modelLoc = glGetUniformLocation(shaderProgram, "model");
    int viewLoc  = glGetUniformLocation(shaderProgram, "view");
    int projLoc  = glGetUniformLocation(shaderProgram, "projection");
    
    while(!glfwWindowShouldClose(window)){
        glfwPollEvents();
        
        int winW, winH;
        glfwGetFramebufferSize(window, &winW, &winH);
        projection = glm::perspective(glm::radians(45.0f), (float)winW/winH, 0.1f, 100.0f);
        
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        
        // UI Panel.
        ImGui::Begin("Robot Arm Controls");
        if(ImGui::Button("Remove Last Joint") && !joints.empty())
            joints.pop_back();
        const char* jointOptions[] = { "Yaw (rotate about Z, moves in XY)", "Pitch (rotate about Y, moves in XZ)" };
        int currentOption = (uiSelectedJoint == YAW) ? 0 : 1;
        if(ImGui::Combo("New Joint Type", &currentOption, jointOptions, IM_ARRAYSIZE(jointOptions))){
            uiSelectedJoint = (currentOption == 0) ? YAW : PITCH;
        }
        ImGui::Text("Right-click (away from the origin) to add a new joint.");
        ImGui::Text("Left-click near the end effector marker (or its gizmo arrows) and drag to move it.");
        ImGui::Text("Middle-click and drag to orbit the camera.");
        ImGui::End();
        
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glUseProgram(shaderProgram);
        glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(projLoc, 1, GL_FALSE, glm::value_ptr(projection));
        
        // Compute forward kinematics.
        std::vector<glm::vec3> positions = computeFK();
        
        // Draw the arm as a line strip.
        std::vector<float> lineVerts;
        for(auto &p : positions){
            lineVerts.push_back(p.x);
            lineVerts.push_back(p.y);
            lineVerts.push_back(p.z);
        }
        glBindVertexArray(lineVAO);
        glBindBuffer(GL_ARRAY_BUFFER, lineVBO);
        glBufferData(GL_ARRAY_BUFFER, lineVerts.size()*sizeof(float), lineVerts.data(), GL_DYNAMIC_DRAW);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        glUniform4f(colorLoc, 1.0f, 0.6f, 0.2f, 1.0f); // orange line
        glm::mat4 ident = glm::mat4(1.0f);
        glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(ident));
        glLineWidth(3.0f);
        glDrawArrays(GL_LINE_STRIP, 0, positions.size());
        
        // Draw joint markers.
        // The first marker (i==0) is the fixed origin drawn with extra stand geometry.
        for(size_t i = 0; i < positions.size(); i++){
            glm::mat4 model = glm::translate(glm::mat4(1.0f), positions[i]);
            model = glm::scale(model, glm::vec3(0.2f));
            glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));
            // Draw the fixed origin in a distinct color (e.g., dark blue).
            if(i == 0)
                glUniform4f(colorLoc, 0.1f, 0.1f, 0.6f, 1.0f);
            else if(i == positions.size()-1)
                glUniform4f(colorLoc, 1.0f, 1.0f, 1.0f, 1.0f); // end effector white
            else
                glUniform4f(colorLoc, 0.2f, 0.2f, 1.0f, 1.0f);
            glBindVertexArray(cubeVAO);
            glDrawArrays(GL_TRIANGLES, 0, 36);
            
            // For the fixed origin cube (i==0), draw the stand with the half-sphere (cup).
            if(i == 0) {
                // --- Draw a vertical pole below the cube.
                // With the cube scaled to 0.2, half-height is 0.1.
                glm::vec3 basePos = positions[0];
                // Define pole from a bit below the cube center to a lower point.
                glm::vec3 poleStartLocal = glm::vec3(0, 0, -0.1f);
                glm::vec3 poleEndLocal   = glm::vec3(0, 0, -0.6f);
                glm::vec3 poleStart = basePos + poleStartLocal;
                glm::vec3 poleEnd   = basePos + poleEndLocal;
                
                std::vector<float> poleVerts = {
                    poleStart.x, poleStart.y, poleStart.z,
                    poleEnd.x,   poleEnd.y,   poleEnd.z
                };
                GLuint poleVAO, poleVBO;
                glGenVertexArrays(1, &poleVAO);
                glGenBuffers(1, &poleVBO);
                glBindVertexArray(poleVAO);
                glBindBuffer(GL_ARRAY_BUFFER, poleVBO);
                glBufferData(GL_ARRAY_BUFFER, poleVerts.size() * sizeof(float), poleVerts.data(), GL_STATIC_DRAW);
                glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
                glEnableVertexAttribArray(0);
                glUniform4f(colorLoc, 0.8f, 0.8f, 0.8f, 1.0f);
                glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(ident));
                glLineWidth(2.0f);
                glDrawArrays(GL_LINES, 0, 2);
                glDeleteVertexArrays(1, &poleVAO);
                glDeleteBuffers(1, &poleVBO);
                
                // --- Draw a half-sphere (cup) below the pole.
                // The cup’s rim coincides with the bottom of the pole (poleEnd).
                float cupRadius = 0.3f;
                int circleSegments = 40;
                int numCircles = 6; // More circles give a smoother cup.
                for (int ci = 1; ci < numCircles; ci++) {
                    // Let theta range from 0 (rim) to π/2 (deepest point).
                    float theta = (float)ci / (numCircles - 1) * (glm::pi<float>() / 2.0f);
                    float currCircleRadius = cupRadius * sin(theta);
                    // Vertical offset: 0 at rim, -cupRadius at deepest point.
                    float circleZ = -cupRadius * (1 - cos(theta));
                    
                    std::vector<float> circleVerts;
                    for (int j = 0; j < circleSegments; j++) {
                        float phi = 2.0f * glm::pi<float>() * j / circleSegments;
                        float x = currCircleRadius * cos(phi);
                        float y = currCircleRadius * sin(phi);
                        float z = circleZ;
                        circleVerts.push_back(poleEnd.x + x);
                        circleVerts.push_back(poleEnd.y + y);
                        circleVerts.push_back(poleEnd.z + z);
                    }
                    GLuint circleVAO, circleVBO;
                    glGenVertexArrays(1, &circleVAO);
                    glGenBuffers(1, &circleVBO);
                    glBindVertexArray(circleVAO);
                    glBindBuffer(GL_ARRAY_BUFFER, circleVBO);
                    glBufferData(GL_ARRAY_BUFFER, circleVerts.size() * sizeof(float), circleVerts.data(), GL_STATIC_DRAW);
                    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
                    glEnableVertexAttribArray(0);
                    glUniform4f(colorLoc, 0.8f, 0.8f, 0.8f, 1.0f);
                    glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(ident));
                    glLineWidth(2.0f);
                    glDrawArrays(GL_LINE_LOOP, 0, circleSegments);
                    glDeleteVertexArrays(1, &circleVAO);
                    glDeleteBuffers(1, &circleVBO);
                }
            }
        }
        
        // --- Draw Gizmo Arrows at the End Effector ---
        glm::vec3 ee = positions.back();
        for (int i = 0; i < 3; i++){
            glm::vec3 dir;
            glm::vec3 col;
            if(i == 0) { dir = glm::vec3(1,0,0); col = glm::vec3(1,0,0); }
            else if(i == 1) { dir = glm::vec3(0,1,0); col = glm::vec3(0,1,0); }
            else { dir = glm::vec3(0,0,1); col = glm::vec3(0,0,1); }
            glm::vec3 tip = ee + arrowLength * dir;
            float arrowVerts[6] = { ee.x, ee.y, ee.z, tip.x, tip.y, tip.z };
            GLuint arrowVAO, arrowVBO;
            glGenVertexArrays(1, &arrowVAO);
            glGenBuffers(1, &arrowVBO);
            glBindVertexArray(arrowVAO);
            glBindBuffer(GL_ARRAY_BUFFER, arrowVBO);
            glBufferData(GL_ARRAY_BUFFER, sizeof(arrowVerts), arrowVerts, GL_STATIC_DRAW);
            glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void*)0);
            glEnableVertexAttribArray(0);
            glUniform4f(colorLoc, col.r, col.g, col.b, 1.0f);
            glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(ident));
            glLineWidth(2.0f);
            glDrawArrays(GL_LINES, 0, 2);
            glDeleteVertexArrays(1, &arrowVAO);
            glDeleteBuffers(1, &arrowVBO);
        }
        
        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        
        glfwSwapBuffers(window);
    }
    
    glDeleteVertexArrays(1, &cubeVAO);
    glDeleteBuffers(1, &cubeVBO);
    glDeleteVertexArrays(1, &lineVAO);
    glDeleteBuffers(1, &lineVBO);
    
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    glfwTerminate();
    return 0;
}
